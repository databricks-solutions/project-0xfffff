# E2E Test Infrastructure

A fluent builder API for writing readable, maintainable e2e tests with sensible defaults and type-safe mock data.

## Quick Start

```typescript
import { test, expect } from '@playwright/test';
import { TestScenario } from './lib';

test('facilitator can create a rubric', async ({ page }) => {
  const scenario = await TestScenario.create(page)
    .withWorkshop({ name: 'My Workshop' })
    .withFacilitator()
    .withParticipants(2)
    .withTraces(5)
    .inPhase('rubric')
    .build();

  await scenario.loginAs(scenario.facilitator);

  // Your test assertions here
  await expect(page.getByRole('heading', { name: 'My Workshop' })).toBeVisible();
});
```

## Design Principles

1. **Fluent builder API** - Chainable methods for all scenarios
2. **Mock by default** - Fast tests with `.withReal()` escape hatch for real API calls
3. **Type-safe** - Leverages autogenerated types from `client/src/client/`
4. **Three user roles** - `facilitator`, `sme`, `participant`
5. **Readable tests** - Tests read like specifications

## TestScenario Builder

### Creating a Scenario

```typescript
const scenario = await TestScenario.create(page)
  // ... configuration
  .build();
```

### Workshop Configuration

```typescript
// Basic workshop
.withWorkshop()

// Named workshop
.withWorkshop({ name: 'Calibration Workshop' })

// With description
.withWorkshop({ name: 'Workshop', description: 'For testing' })
```

### User Configuration

```typescript
// Add a facilitator (uses default credentials)
.withFacilitator()

// Custom facilitator
.withFacilitator({ email: 'custom@test.com', name: 'Custom Facilitator' })

// Add participants
.withParticipants(3)  // Creates 3 participants with generated emails

// Add SMEs
.withSMEs(2)  // Creates 2 SME users

// Add specific named users
.withUser('participant', { email: 'alice@test.com', name: 'Alice' })
.withUser('sme', { email: 'expert@test.com', name: 'Dr. Expert' })
```

### Data Configuration

```typescript
// Add traces
.withTraces(5)  // Creates 5 traces with sample data

// Add a rubric
.withRubric({ question: 'How helpful is this response?' })

// Add discovery findings
.withDiscoveryFinding({ insight: 'The response was helpful' })

// Mark discovery as complete (for later phase tests)
.withDiscoveryComplete()

// Add annotations
.withAnnotation({ rating: 4, comment: 'Good response' })
```

### Phase Configuration

```typescript
// Set the workshop to a specific phase
.inPhase('discovery')
.inPhase('rubric')
.inPhase('annotation')
.inPhase('results')
```

Available phases: `intake`, `discovery`, `rubric`, `annotation`, `results`, `judge_tuning`, `unity_volume`

### Mock vs Real API

```typescript
// Default: everything mocked (fast tests)
.build()

// Make specific endpoints real
.withReal('/users/auth/login')
.withReal('/workshops')

// Make specific services real
.withReal('WorkshopsService')
.withReal('UsersService')

// Everything real (full e2e, slower)
.withRealApi()
```

## Accessing Scenario Data

After calling `.build()`, the scenario provides access to all created entities:

```typescript
const scenario = await TestScenario.create(page)
  .withWorkshop({ name: 'Test' })
  .withFacilitator()
  .withParticipants(2)
  .withSMEs(1)
  .withTraces(3)
  .build();

// Workshop
scenario.workshop           // Workshop object
scenario.workshop.id        // Workshop ID
scenario.workshop.name      // "Test"

// Users
scenario.facilitator        // First facilitator user
scenario.users.facilitator  // Array of all facilitators
scenario.users.participant  // Array of all participants
scenario.users.sme          // Array of all SMEs

// Data
scenario.traces             // Array of all traces
scenario.rubric             // Rubric object (if created)
scenario.findings           // Array of discovery findings
scenario.annotations        // Array of annotations
```

## Actions

The scenario provides actions for common operations:

### Authentication

```typescript
// Login as any user
await scenario.loginAs(scenario.facilitator);
await scenario.loginAs(scenario.users.participant[0]);

// Logout
await scenario.logout();
```

### Navigation

```typescript
// Navigate to a phase view
await scenario.goToPhase('discovery');
await scenario.goToPhase('rubric');

// Navigate to a tab
await scenario.goToTab('Rubric Questions');
```

### Phase Advancement (API)

```typescript
// Advance workshop phase via API
await scenario.advanceToPhase('discovery');
await scenario.advanceToPhase('rubric');
```

### Data Creation

```typescript
// Create a rubric question via UI
await scenario.createRubricQuestion({
  question: 'How helpful is this response?'
});

// Submit a discovery finding
await scenario.submitFinding({
  trace: scenario.traces[0],
  insight: 'The response was accurate'
});

// Submit an annotation
await scenario.submitAnnotation({
  rating: 4,
  comment: 'Good response'
});

// Complete discovery phase
await scenario.completeDiscovery();
```

## Multi-Browser Tests

For tests requiring multiple browser contexts (e.g., facilitator and participants):

```typescript
test('multi-user workflow', async ({ browser }) => {
  const scenario = await TestScenario.create(browser)
    .withWorkshop()
    .withFacilitator()
    .withParticipants(2)
    .withTraces(3)
    .inPhase('discovery')
    .build();

  // Create separate browser pages for each user
  const facilitatorPage = await scenario.newPageAs(scenario.facilitator);
  const alicePage = await scenario.newPageAs(scenario.users.participant[0]);
  const bobPage = await scenario.newPageAs(scenario.users.participant[1]);

  // Use actions scoped to a specific page
  await scenario.using(alicePage).submitFinding({
    trace: scenario.traces[0],
    insight: 'Good response'
  });

  // Verify on facilitator's page
  await expect(facilitatorPage.getByText('1 finding')).toBeVisible();
});
```

## API Access

Direct API access for assertions:

```typescript
// Get current workshop state
const workshop = await scenario.api.getWorkshop();

// Get rubric
const rubric = await scenario.api.getRubric();

// Get traces
const traces = await scenario.api.getTraces();

// Get findings
const findings = await scenario.api.getFindings();
const userFindings = await scenario.api.getFindings(userId);

// Get annotations
const annotations = await scenario.api.getAnnotations();

// Get discovery completion status
const status = await scenario.api.getDiscoveryCompletionStatus();
// { total_participants: 2, completed_participants: 1, all_completed: false }
```

## Cleanup

Always clean up after tests:

```typescript
test('my test', async ({ page }) => {
  const scenario = await TestScenario.create(page)
    .withWorkshop()
    .build();

  try {
    // Test code
  } finally {
    await scenario.cleanup();
  }
});
```

## Examples

### Simple Login Test

```typescript
test('facilitator can login', async ({ page }) => {
  const scenario = await TestScenario.create(page)
    .withWorkshop({ name: 'Test Workshop' })
    .withFacilitator()
    .build();

  await page.goto('/');
  await scenario.loginAs(scenario.facilitator);

  await expect(page.getByRole('heading', { name: 'Test Workshop' })).toBeVisible();
  await scenario.cleanup();
});
```

### Discovery Phase Test

```typescript
test('participant submits finding', async ({ page }) => {
  const scenario = await TestScenario.create(page)
    .withWorkshop()
    .withFacilitator()
    .withParticipants(1)
    .withTraces(1)
    .inPhase('discovery')
    .build();

  await page.goto('/');
  await scenario.loginAs(scenario.users.participant[0]);

  await scenario.submitFinding({
    trace: scenario.traces[0],
    insight: 'The response addresses the question well'
  });

  await scenario.cleanup();
});
```

### Rubric Creation Test

```typescript
test('facilitator creates rubric after discovery', async ({ page }) => {
  const scenario = await TestScenario.create(page)
    .withWorkshop()
    .withFacilitator()
    .withParticipants(1)
    .withTraces(1)
    .withDiscoveryFinding()
    .withDiscoveryComplete()
    .inPhase('rubric')
    .build();

  await page.goto('/');
  await scenario.loginAs(scenario.facilitator);

  await scenario.createRubricQuestion({
    question: 'How helpful is this response?'
  });

  const rubric = await scenario.api.getRubric();
  expect(rubric?.question).toContain('helpful');

  await scenario.cleanup();
});
```

### Full E2E with Real API

```typescript
test('real API test', async ({ page }) => {
  const scenario = await TestScenario.create(page)
    .withWorkshop()
    .withFacilitator()
    .withRealApi()  // No mocking
    .build();

  await page.goto('/');
  await scenario.loginAs(scenario.facilitator);

  // All API calls go to real backend
  await scenario.cleanup();
});
```

## File Structure

```
client/tests/lib/
├── index.ts                 # Main exports
├── types.ts                 # Type definitions (re-exports from client/src/client/)
├── scenario-builder.ts      # TestScenario class
├── mocks/
│   ├── index.ts
│   ├── api-mocker.ts        # Playwright route interception
│   └── response-builder.ts  # Type-safe mock data builders
├── actions/
│   ├── index.ts
│   ├── auth.ts              # loginAs, logout
│   ├── workshop.ts          # goToPhase, advanceToPhase
│   ├── discovery.ts         # submitFinding, completeDiscovery
│   ├── rubric.ts            # createRubricQuestion
│   └── annotation.ts        # submitAnnotation
└── data/
    ├── index.ts
    └── defaults.ts          # Default test data, sample traces
```

## Types

All types are re-exported from the autogenerated client types:

```typescript
import type {
  User,
  UserRole,           // 'facilitator' | 'sme' | 'participant'
  Workshop,
  WorkshopPhase,      // 'intake' | 'discovery' | 'rubric' | ...
  Trace,
  Rubric,
  Annotation,
  DiscoveryFinding,
} from './lib';
```

## Running Tests

```bash
# Run all e2e tests
just e2e

# Run specific test file
just e2e-test && npx playwright test tests/e2e/my-test.spec.ts

# Run in headed mode (see browser)
just e2e headed

# Run with UI mode
just e2e ui
```
